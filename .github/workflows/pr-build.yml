name: PR Build

on:
  pull_request:
    branches:
      - "*"
  workflow_dispatch:

jobs:
  prepare:
    name: Prepare Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      clean_version: ${{ steps.version.outputs.clean_version }}
      latest_tag: ${{ steps.version.outputs.latest_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate PR version
        id: version
        shell: bash
        env:
          PR_NUMBER: ${{ github.event.number }}
        run: |
          set -eo pipefail

          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          COMMIT_HASH=$(git rev-parse --short HEAD)

          if [ -n "${PR_NUMBER}" ]; then
            VERSION="${LATEST_TAG}-dev-${COMMIT_HASH}-pr${PR_NUMBER}"
          else
            VERSION="${LATEST_TAG}-dev-${COMMIT_HASH}"
          fi

          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "clean_version=${VERSION#v}" >> "$GITHUB_OUTPUT"
          echo "latest_tag=${LATEST_TAG}" >> "$GITHUB_OUTPUT"
          echo "Generated version: ${VERSION}"

  build:
    name: Build Binaries
    needs: prepare
    runs-on: ${{ matrix.os }}
    env:
      VERSION: ${{ needs.prepare.outputs.version }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            goos: linux
            goarch: amd64
            cgo: "0"
            name: mcpproxy-linux-amd64
            archive_format: tar.gz
          - os: ubuntu-latest
            goos: linux
            goarch: arm64
            cgo: "0"
            name: mcpproxy-linux-arm64
            archive_format: tar.gz
          - os: ubuntu-latest
            goos: windows
            goarch: amd64
            cgo: "0"
            name: mcpproxy-windows-amd64.exe
            archive_format: zip
          - os: ubuntu-latest
            goos: windows
            goarch: arm64
            cgo: "0"
            name: mcpproxy-windows-arm64.exe
            archive_format: zip
          - os: macos-14
            goos: darwin
            goarch: amd64
            cgo: "1"
            name: mcpproxy-darwin-amd64
            archive_format: tar.gz
          - os: macos-14
            goos: darwin
            goarch: arm64
            cgo: "1"
            name: mcpproxy-darwin-arm64
            archive_format: tar.gz

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.23.10"
          cache: false  # Disable built-in cache to use explicit cache step below

      - name: Clean Go module cache (macOS workaround)
        if: runner.os == 'macOS'
        run: |
          # Remove potentially corrupted toolchain files
          rm -rf ~/go/pkg/mod/golang.org/toolchain* || true

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Download dependencies
        run: go mod download

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install frontend dependencies
        run: cd frontend && npm ci

      - name: Build frontend
        run: cd frontend && npm run build

      - name: Copy frontend dist for embedding
        run: |
          rm -rf web/frontend
          mkdir -p web/frontend
          cp -r frontend/dist web/frontend/

      - name: Run tests (skip binary E2E tests - not compatible with cross-compilation)
        run: go test -tags nogui -v -skip "E2E|Binary|MCPProtocol" ./...

      - name: Build binary and create archives
        env:
          CGO_ENABLED: ${{ matrix.cgo }}
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          VERSION: ${{ env.VERSION }}
          # âœ… Force minimum supported macOS version for compatibility
          MACOSX_DEPLOYMENT_TARGET: "12.0"
          # Defensive CGO flags to ensure proper deployment target
          CGO_CFLAGS: "-mmacosx-version-min=12.0"
          CGO_LDFLAGS: "-mmacosx-version-min=12.0"
        run: |
          LDFLAGS="-s -w -X mcpproxy-go/cmd/mcpproxy.version=${VERSION} -X main.version=${VERSION}"

          # Determine clean binary name
          if [ "${{ matrix.goos }}" = "windows" ]; then
            CLEAN_BINARY="mcpproxy.exe"
          else
            CLEAN_BINARY="mcpproxy"
          fi

          # Create clean core binary for archive
          go build -ldflags "${LDFLAGS}" -o ${CLEAN_BINARY} ./cmd/mcpproxy

          # Build tray binary for macOS
          if [ "${{ matrix.goos }}" = "darwin" ]; then
            echo "Building mcpproxy-tray for macOS..."
            go build -ldflags "${LDFLAGS}" -o mcpproxy-tray ./cmd/mcpproxy-tray
          fi

          # Ad-hoc sign macOS binaries (development only)
          if [ "${{ matrix.goos }}" = "darwin" ]; then
            echo "Ad-hoc signing macOS binaries for development..."
            codesign --force --deep --sign - --identifier "com.smartmcpproxy.mcpproxy.dev" ${CLEAN_BINARY}
            codesign --force --deep --sign - --identifier "com.smartmcpproxy.mcpproxy-tray.dev" mcpproxy-tray

            # Verify signing
            codesign --verify --verbose ${CLEAN_BINARY}
            codesign --verify --verbose mcpproxy-tray
            echo "Binaries signed successfully (development)"
          fi

          # Create archive with version info
          ARCHIVE_BASE="mcpproxy-${VERSION#v}-${{ matrix.goos }}-${{ matrix.goarch }}"

          if [ "${{ matrix.archive_format }}" = "zip" ]; then
            # Create archive
            zip "${ARCHIVE_BASE}.zip" ${CLEAN_BINARY}
          else
            # Create archive
            tar -czf "${ARCHIVE_BASE}.tar.gz" ${CLEAN_BINARY}
          fi

      - name: Create .icns icon (macOS)
        if: matrix.goos == 'darwin'
        run: |
          chmod +x scripts/create-icns.sh
          ./scripts/create-icns.sh

      - name: Create DMG installer (macOS)
        if: matrix.goos == 'darwin'
        env:
          VERSION: ${{ env.VERSION }}
          # Ensure DMG creation also uses correct deployment target
          MACOSX_DEPLOYMENT_TARGET: "12.0"
          CGO_CFLAGS: "-mmacosx-version-min=12.0"
          CGO_LDFLAGS: "-mmacosx-version-min=12.0"
        run: |
          chmod +x scripts/create-dmg.sh

          # Determine binary names
          TRAY_BINARY="mcpproxy-tray"
          CORE_BINARY="mcpproxy"

          # Create DMG with both tray and core binaries
          ./scripts/create-dmg.sh ${TRAY_BINARY} ${CORE_BINARY} ${VERSION} ${{ matrix.goarch }}

          # Ad-hoc sign DMG (development only)
          DMG_NAME="mcpproxy-${VERSION#v}-darwin-${{ matrix.goarch }}.dmg"
          echo "Ad-hoc signing DMG for development: ${DMG_NAME}"
          codesign --force --deep --sign - "${DMG_NAME}"

          echo "DMG created and signed (development): ${DMG_NAME}"

      - name: Skip notarization (PR Build)
        if: matrix.goos == 'darwin'
        run: |
          echo "Skipping notarization for PR build - this is a development build"
          echo "Production builds go through full notarization in release workflow"

      - name: Upload archive artifact
        uses: actions/upload-artifact@v4
        with:
          name: archive-${{ matrix.goos }}-${{ matrix.goarch }}
          path: mcpproxy-*-${{ matrix.goos }}-${{ matrix.goarch }}.${{ matrix.archive_format }}
          retention-days: 14

      - name: Upload DMG installer (macOS)
        if: matrix.goos == 'darwin'
        uses: actions/upload-artifact@v4
        with:
          name: dmg-${{ matrix.goos }}-${{ matrix.goarch }}
          path: mcpproxy-*-darwin-${{ matrix.goarch }}.dmg
          retention-days: 14

  announce:
    name: Share Artifacts
    needs:
      - prepare
      - build
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    env:
      VERSION: ${{ needs.prepare.outputs.version }}
      CLEAN_VERSION: ${{ needs.prepare.outputs.clean_version }}
      LATEST_TAG: ${{ needs.prepare.outputs.latest_tag }}
      RETENTION_DAYS: "14"
    steps:
      - name: Publish artifact summary
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request?.number;
            if (!prNumber) {
              core.info('No pull request context; skipping comment.');
              return;
            }

            const runId = context.runId;
            const artifacts = await github.paginate(
              github.rest.actions.listWorkflowRunArtifacts,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: runId,
                per_page: 100
              }
            );

            if (artifacts.length === 0) {
              core.info('No artifacts found for this run.');
              return;
            }

            const formatSize = (bytes) => {
              if (!bytes) {
                return '0 B';
              }
              const units = ['B', 'KB', 'MB', 'GB'];
              const exponent = Math.min(units.length - 1, Math.floor(Math.log(bytes) / Math.log(1024)));
              const value = bytes / Math.pow(1024, exponent);
              return `${value.toFixed(value >= 10 || exponent === 0 ? 0 : 1)} ${units[exponent]}`;
            };

            const artifactLines = artifacts.map((artifact) => {
              const size = formatSize(artifact.size_in_bytes);
              return `- [${artifact.name}](${artifact.archive_download_url}) -> ${size}`;
            });

            const tableRows = artifacts
              .map((artifact) => `| ${artifact.name} | ${formatSize(artifact.size_in_bytes)} | [Download](${artifact.archive_download_url}) |`)
              .join('\n');

            await core.summary
              .addHeading('Pull Request Artifacts')
              .addRaw(`| Name | Size | Link |\n| --- | --- | --- |\n${tableRows}`, true)
              .addRaw(`\n\nVersion: ${process.env.VERSION}`)
              .addRaw(`\nLatest tag: ${process.env.LATEST_TAG}`)
              .addRaw(`\nLinks expire in ${process.env.RETENTION_DAYS} days.`)
              .write();

            const marker = '<!-- mcpproxy-pr-artifacts -->';
            const bodyLines = [
              marker,
              `Build artifacts for PR #${prNumber}`,
              '',
              `Version: \`${process.env.VERSION}\``,
              `Latest tag: \`${process.env.LATEST_TAG}\``,
              '',
              ...artifactLines,
              '',
              `Links expire in ${process.env.RETENTION_DAYS} days.`
            ];
            const body = bodyLines.join('\n');

            const existingComments = await github.paginate(
              github.rest.issues.listComments,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
              }
            );

            const previous = existingComments.find(
              (comment) =>
                comment.user?.login === 'github-actions[bot]' &&
                comment.body?.includes(marker)
            );

            if (previous) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: previous.id,
                body
              });
              core.info(`Updated existing artifact comment (${previous.id}).`);
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body
              });
              core.info('Created new artifact comment.');
            }
