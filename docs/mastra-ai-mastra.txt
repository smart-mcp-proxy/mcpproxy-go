Directory structure:
└── mcp-registry-registry/
    ├── README.md
    ├── eslint.config.js
    ├── package.json
    ├── tsconfig.json
    ├── turbo.json
    ├── vitest.config.ts
    └── src/
        ├── index.ts
        ├── server.ts
        ├── stdio.ts
        ├── utils.ts
        ├── registry/
        │   ├── fetch-servers.ts
        │   ├── index.ts
        │   ├── list-registries.ts
        │   ├── registry.ts
        │   ├── types.ts
        │   ├── __tests__/
        │   │   ├── fetch-servers.test.ts
        │   │   ├── list-registries.test.ts
        │   │   └── processors/
        │   │       ├── apify.test.ts
        │   │       ├── apitracker.test.ts
        │   │       ├── docker.test.ts
        │   │       ├── fleur.test.ts
        │   │       ├── mcprun.test.ts
        │   │       └── pulse.test.ts
        │   └── processors/
        │       ├── apify.ts
        │       ├── apitracker.ts
        │       ├── default.ts
        │       ├── docker.ts
        │       ├── fleur.ts
        │       ├── mcprun.ts
        │       ├── pulse.ts
        │       └── utils.ts
        └── tools/
            ├── list.ts
            └── servers.ts

================================================
FILE: packages/mcp-registry-registry/README.md
================================================
# @mastra/mcp-registry-registry

An MCP server that provides a registry of MCP registries, allowing discovery and access to MCP servers across multiple registries.

## Overview

The MCP Registry Registry serves as a meta-registry, aggregating information about various MCP registries and providing a unified interface to discover and access MCP servers across the ecosystem. This package implements the [Model Context Protocol (MCP)](https://modelcontextprotocol.ai/) specification, making it compatible with any MCP client.

## Features

- **Registry Listing**: Browse and filter available MCP registries
- **Server Discovery**: Fetch servers from specific registries

## Installation

```bash
# Using npm
npm install @mastra/mcp-registry-registry

# Using pnpm
pnpm add @mastra/mcp-registry-registry

# Using yarn
yarn add @mastra/mcp-registry-registry
```

## Available Tools

### `registryList`

Lists available MCP registries with filtering options.

### `registryServers`

Fetches servers from a specific registry with filtering options.



================================================
FILE: packages/mcp-registry-registry/eslint.config.js
================================================
import { createConfig } from '@internal/lint/eslint';

const config = await createConfig();

/** @type {import("eslint").Linter.Config[]} */
export default [...config];



================================================
FILE: packages/mcp-registry-registry/package.json
================================================
{
  "name": "@mastra/mcp-registry-registry",
  "version": "0.10.4",
  "description": "MCP server for registry registry services.",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "bin": "dist/stdio.js",
  "files": [
    "dist",
    "README.md"
  ],
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      }
    },
    "./package.json": "./package.json"
  },
  "scripts": {
    "build": "tsup src/index.ts src/stdio.ts --format esm --experimental-dts --treeshake=smallest --splitting",
    "build:cli": "tsup src/stdio.ts --format esm --experimental-dts --treeshake=smallest --splitting",
    "pretest": "pnpm turbo build --filter @mastra/mcp-registry-registry",
    "test": "vitest run",
    "lint": "eslint ."
  },
  "keywords": [],
  "author": "",
  "license": "Apache-2.0",
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.13.0",
    "uuid": "^11.1.0",
    "zod": "^3.25.67",
    "zod-to-json-schema": "^3.24.5"
  },
  "devDependencies": {
    "@hono/node-server": "^1.14.4",
    "@internal/lint": "workspace:*",
    "@mastra/core": "workspace:*",
    "@mastra/mcp": "workspace:^",
    "@types/node": "^20.19.0",
    "@wong2/mcp-cli": "^1.10.0",
    "cross-env": "^7.0.3",
    "eslint": "^9.30.1",
    "hono": "^4.8.4",
    "tsup": "^8.5.0",
    "tsx": "^4.20.3",
    "typescript": "^5.8.3",
    "vitest": "^3.2.4"
  },
  "peerDependencies": {
    "@mastra/core": "^0.10.0-alpha.0"
  }
}



================================================
FILE: packages/mcp-registry-registry/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "lib": ["ES2022"],
    "declaration": true,
    "outDir": "./dist",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}



================================================
FILE: packages/mcp-registry-registry/turbo.json
================================================
{
  "$schema": "https://turbo.build/schema.json",
  "extends": ["//"],
  "tasks": {
    "build": {
      "outputs": ["dist/**"],
      "dependsOn": ["^build"]
    },
    "build:cli": {
      "outputs": ["dist/**"],
      "dependsOn": ["^build"]
    },
    "test": {
      "dependsOn": ["build", "build:cli"],
      "outputs": []
    }
  }
}



================================================
FILE: packages/mcp-registry-registry/vitest.config.ts
================================================
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
  },
});



================================================
FILE: packages/mcp-registry-registry/src/index.ts
================================================
export * from './registry/registry';



================================================
FILE: packages/mcp-registry-registry/src/server.ts
================================================
import fs from 'node:fs/promises';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';
import { zodToJsonSchema } from 'zod-to-json-schema';

import { listTool, listInputSchema } from './tools/list';
import { serversTool, serversInputSchema } from './tools/servers';
import { fromPackageRoot } from './utils';

const server = new Server(
  {
    name: 'Registry Registry Server',
    version: JSON.parse(await fs.readFile(fromPackageRoot(`package.json`), 'utf8')).version,
  },
  {
    capabilities: {
      tools: {},
    },
  },
);

// Set up request handlers
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: [
    {
      name: 'registryList',
      description: listTool.description,
      inputSchema: zodToJsonSchema(listInputSchema),
    },
    {
      name: 'registryServers',
      description: serversTool.description,
      inputSchema: zodToJsonSchema(serversInputSchema),
    },
  ],
}));

server.setRequestHandler(CallToolRequestSchema, async request => {
  try {
    switch (request.params.name) {
      case 'registryList': {
        const args = listInputSchema.parse(request.params.arguments);
        return await listTool.execute(args);
      }
      case 'registryServers': {
        const args = serversInputSchema.parse(request.params.arguments);
        return await serversTool.execute(args);
      }
      default:
        return {
          content: [
            {
              type: 'text',
              text: `Unknown tool: ${request.params.name}`,
            },
          ],
          isError: true,
        };
    }
  } catch (error) {
    if (error instanceof z.ZodError) {
      return {
        content: [
          {
            type: 'text',
            text: `Invalid arguments: ${error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ')}`,
          },
        ],
        isError: true,
      };
    }
    return {
      content: [
        {
          type: 'text',
          text: `Error: ${error instanceof Error ? error.message : String(error)}`,
        },
      ],
      isError: true,
    };
  }
});

async function runServer() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('Registry Registry MCP Server running on stdio');
}

export { runServer, server };



================================================
FILE: packages/mcp-registry-registry/src/stdio.ts
================================================
#!/usr/bin/env node
import { runServer } from './server.js';

runServer().catch(error => {
  console.error('Failed to start server:', error);
  process.exit(1);
});



================================================
FILE: packages/mcp-registry-registry/src/utils.ts
================================================
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export function fromPackageRoot(relativePath: string): string {
  return path.resolve(__dirname, '..', relativePath);
}



================================================
FILE: packages/mcp-registry-registry/src/registry/fetch-servers.ts
================================================
import { registryData } from './registry';
import type { ServerEntry } from './types';

/**
 * Fetches servers from a registry's servers_url endpoint
 */
export async function fetchServersFromRegistry(registryId: string): Promise<ServerEntry[]> {
  try {
    // Find the registry in our registry data
    const registry = registryData.registries.find(r => r.id === registryId);

    if (!registry) {
      throw new Error(`Registry with ID "${registryId}" not found.`);
    }

    if (!registry.servers_url) {
      throw new Error(`Registry "${registry.name}" does not have a servers endpoint.`);
    }

    console.log(`Fetching servers from ${registry.name} at ${registry.servers_url}`);

    // Fetch the servers from the registry's servers_url
    const response = await fetch(registry.servers_url);

    if (!response.ok) {
      throw new Error(`Failed to fetch servers from ${registry.servers_url}: ${response.statusText}`);
    }

    const data = (await response.json()) as unknown;

    // If the registry has a custom post-processing function, use it
    if (registry.postProcessServers) {
      console.log(`Using custom post-processor for ${registry.name}`);
      return registry.postProcessServers(data);
    }

    throw new Error(`No post-processor found for registry ${registry.name}`);
  } catch (error) {
    console.error('Error fetching servers:', error);
    throw error;
  }
}

/**
 * Filters server entries based on provided criteria
 */
export function filterServers(
  servers: ServerEntry[],
  filters: {
    tag?: string;
    search?: string;
  },
): ServerEntry[] {
  let filteredServers = [...servers];

  if (filters.search) {
    const searchTerm = filters.search.toLowerCase();
    filteredServers = filteredServers.filter(
      server => server.name.toLowerCase().includes(searchTerm) || server.description.toLowerCase().includes(searchTerm),
    );
  }

  return filteredServers;
}

/**
 * Main function to get servers from a registry with optional filtering
 */
export async function getServersFromRegistry(
  registryId: string,
  filters: {
    tag?: string;
    search?: string;
  } = {},
): Promise<any> {
  try {
    const servers = await fetchServersFromRegistry(registryId);
    return filterServers(servers, filters);
  } catch (error) {
    console.error('Error getting servers from registry:', error);
    throw error;
  }
}



================================================
FILE: packages/mcp-registry-registry/src/registry/index.ts
================================================
export * from './list-registries';
export * from './fetch-servers';



================================================
FILE: packages/mcp-registry-registry/src/registry/list-registries.ts
================================================
import { z } from 'zod';
import { registryData } from './registry';
import type { RegistryEntry, RegistryFile } from './types';

// Define the schema for registry entries for validation
const RegistryEntrySchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string(),
  url: z.string().url(),
  servers_url: z.string().url().optional(),
  tags: z.array(z.string()).optional(),
  count: z.union([z.number(), z.string()]).optional(),
});

// Define the schema for the registry file for validation
const RegistryFileSchema = z.object({
  registries: z.array(RegistryEntrySchema),
});

/**
 * Returns the registry data from the registry.ts file
 */
export async function loadRegistryData(): Promise<RegistryFile> {
  try {
    // Validate the registry data against our schema
    return RegistryFileSchema.parse(registryData);
  } catch (error) {
    console.error('Error loading registry data:', error);
    return { registries: [] };
  }
}

/**
 * Filters registry entries based on provided criteria
 */
export function filterRegistries(
  registries: RegistryEntry[],
  filters: {
    id?: string;
    tag?: string;
    name?: string;
  },
): RegistryEntry[] {
  let filteredRegistries = [...registries];

  if (filters.id) {
    filteredRegistries = filteredRegistries.filter(registry => registry.id === filters.id);
  }

  if (filters.tag) {
    filteredRegistries = filteredRegistries.filter(registry => registry.tags?.includes(filters.tag!));
  }

  if (filters.name) {
    const searchTerm = filters.name.toLowerCase();
    filteredRegistries = filteredRegistries.filter(registry => registry.name.toLowerCase().includes(searchTerm));
  }

  return filteredRegistries;
}

/**
 * Formats registry entries for API response
 */
export function formatRegistryResponse(registries: RegistryEntry[], detailed: boolean = false): any {
  if (registries.length === 0) {
    return {
      count: 0,
      registries: [],
    };
  }

  if (detailed) {
    return {
      count: registries.length,
      registries: registries.map(registry => ({
        id: registry.id,
        name: registry.name,
        description: registry.description,
        url: registry.url,
        servers_url: registry.servers_url,
        tags: registry.tags || [],
        count: registry.count,
      })),
    };
  }

  return {
    count: registries.length,
    registries: registries.map(registry => ({
      id: registry.id,
      name: registry.name,
      description: registry.description,
    })),
  };
}

/**
 * Main function to get registry listings with optional filtering
 */
export async function getRegistryListings(
  filters: {
    id?: string;
    tag?: string;
    name?: string;
  } = {},
  options: {
    detailed?: boolean;
  } = {},
): Promise<any> {
  try {
    const registryData = await loadRegistryData();
    const filteredRegistries = filterRegistries(registryData.registries, filters);
    return formatRegistryResponse(filteredRegistries, options.detailed);
  } catch (error) {
    console.error('Error getting registry listings:', error);
    throw error;
  }
}



================================================
FILE: packages/mcp-registry-registry/src/registry/registry.ts
================================================
import { processApifyServers } from './processors/apify';
import { processApiTrackerServers } from './processors/apitracker';
import { processDockerServers } from './processors/docker';
import { processFleurServers } from './processors/fleur';
import { processMcpRunServers } from './processors/mcprun';
import { processPulseMcpServers } from './processors/pulse';
import type { RegistryFile } from './types';

// Registry data with post-processing functions
export const registryData: RegistryFile = {
  registries: [
    {
      id: 'apitracker',
      name: 'API Tracker',
      description: 'Discover the best APIs and developer resources',
      url: 'https://apitracker.com/',
      servers_url: 'https://apitracker.io/api/mcp-servers',
      tags: ['verified'],
      postProcessServers: processApiTrackerServers,
    },
    {
      id: 'docker-mcp-catalog',
      name: 'Docker MCP Catalog',
      description: 'A collection of secure, high quality MCP servers as docker images',
      url: 'https://hub.docker.com/catalogs/mcp',
      servers_url: 'https://hub.docker.com/v2/repositories/mcp/',
      tags: ['verified'],
      count: 102,
      postProcessServers: processDockerServers,
    },
    {
      id: 'apify',
      name: 'Apify',
      description: 'A MCP marketplace enabling AI agents to use 5,000+ ready-made servers and Actors.',
      url: 'https://apify.com/store',
      servers_url: 'https://api.apify.com/v2/store',
      tags: ['verified'],
      count: '5000+',
      postProcessServers: processApifyServers,
    },
    {
      id: 'awesome-mcp-servers',
      name: 'Awesome MCP servers',
      description: 'A curated list of awesome Model Context Protocol (MCP) servers.',
      url: 'https://github.com/punkpeye/awesome-mcp-servers',
      tags: ['open-source'],
      count: 370,
    },
    {
      id: 'cline',
      name: 'Cline.bot',
      description: 'MCP servers for Cline.bot',
      url: 'https://cline.bot/mcp-marketplace',
      tags: ['verified'],
    },
    {
      id: 'cursor',
      name: 'Cursor MCP Registry',
      description: 'Browse MCPs or post a MCP to reach 250,000+ monthly active developers.',
      url: 'https://cursor.directory/mcp',
      tags: ['verified'],
      count: '1800+',
    },
    {
      id: 'dextermcp',
      name: 'Dexter MCP',
      description: 'Enhance your AI with specialized MCP servers for various tasks',
      url: 'https://www.dextermcp.net/',
      tags: ['verified'],
    },
    {
      id: 'fleur',
      name: 'Fleur',
      description: 'Fleur is the app store for Claude',
      url: 'https://www.fleurmcp.com/',
      servers_url: 'https://raw.githubusercontent.com/fleuristes/app-registry/refs/heads/main/apps.json',
      tags: ['verified'],
      postProcessServers: processFleurServers,
    },
    {
      id: 'glama',
      name: 'Glama MCP Server',
      description: 'Production-ready and experimental MCP servers that extend AI capabilities.',
      url: 'https://glama.ai/mcp/servers',
      tags: ['open-source'],
      count: 3457,
    },
    {
      id: 'gumloop',
      name: 'Gumloop',
      description: 'An exhaustive list of MCP servers.',
      url: 'https://www.gumloop.com/mcp',
      tags: ['open-source'],
      count: 20,
    },
    {
      id: 'klavisai',
      name: 'Klavis AI',
      description: 'Klavis AI is open source MCP integrations for AI Applications',
      url: 'https://github.com/Klavis-AI/klavis',
      tags: ['open-source'],
    },
    {
      id: 'make',
      name: 'Make MCP',
      description: 'Connect AI models to 1000+ apps with Make automation platform',
      url: 'https://developers.make.com/mcp-server',
      tags: ['verified'],
    },
    {
      id: 'composio',
      name: 'MCP Composio',
      description: 'Instantly Connect to 100+ Managed MCP Servers with Built-In Auth',
      url: 'https://mcp.composio.dev/',
      tags: ['verified'],
      count: '100+',
    },
    {
      id: 'mcpbar',
      name: 'MCP Bar',
      description: 'Open Registry & Package Manager for MCP Servers',
      url: 'https://www.mcp.bar/',
      tags: ['open-source'],
      count: 4429,
    },
    {
      id: 'mcpget',
      name: 'MCP-Get',
      description: 'mcp-get helps you easily install protocol servers.',
      url: 'https://mcp-get.com/',
      tags: ['open-source'],
      count: 69,
    },
    {
      id: 'mcpmarket',
      name: 'MCP Market',
      description: 'Explore our curated collection of MCP servers to connect AI to your favorite tools.',
      url: 'https://mcpmarket.com/',
      count: 12454,
    },
    {
      id: 'mcprepository',
      name: 'MCP Repository',
      description: 'Discover the ultimate resource for Model Context Protocol at MCP Repository',
      url: 'https://mcprepository.com',
      tags: ['verified'],
    },
    {
      id: 'mcpresolver',
      name: 'MCP Resolver',
      description: 'Find and connect to the right MCP servers for your AI applications',
      url: 'https://mcpresolver.com/',
      tags: ['verified'],
    },
    {
      id: 'mcprun',
      name: 'MCP Run',
      description: 'One platform for vertical AI across your entire organization.',
      url: 'https://www.mcp.run/',
      servers_url: 'https://www.mcp.run/api/servlets',
      tags: ['verified'],
      postProcessServers: processMcpRunServers,
    },
    {
      id: 'mcpserversorg',
      name: 'MCP Servers',
      description: 'A collection of servers for the Model Context Protocol.',
      url: 'https://mcpservers.org/',
      tags: ['open-source'],
      count: 212,
    },
    {
      id: 'mcpso',
      name: 'MCP.so',
      description: 'Find Awesome MCP Servers and Clients',
      url: 'https://mcp.so/',
      tags: ['verified'],
      count: 7682,
    },
    {
      id: 'mcpstore',
      name: 'MCP Store',
      description: 'Discover and use a variety of MCP servers for your AI applications',
      url: 'http://mcpstore.co/',
      tags: ['open-source'],
    },
    {
      id: 'modelcontextprotocol-servers',
      name: 'modelcontextprotocol/servers',
      description: 'This repository is a collection of reference implementations for the Model Context Protocol (MCP).',
      url: 'https://github.com/modelcontextprotocol/servers',
      tags: ['official'],
      count: 307,
    },
    {
      id: 'opentools',
      name: 'OpenTools',
      description: 'This registry documents the capabilities of 400+ tools across 160+ MCP servers.',
      url: 'https://opentools.com/registry',
      tags: ['verified'],
      count: 171,
    },
    {
      id: 'pipedream',
      name: 'Pipedream MCP',
      description: 'The AI developer toolkit for integrations',
      url: 'https://mcp.pipedream.com/',
      tags: ['verified'],
    },
    {
      id: 'pulse',
      name: 'Pulse MCP',
      description: 'Browse and discover MCP use cases, servers, clients, and news.',
      url: 'https://www.pulsemcp.com/',
      servers_url: 'https://api.pulsemcp.com/v0beta/servers',
      tags: ['verified'],
      count: 3653,
      postProcessServers: processPulseMcpServers,
    },
    {
      id: 'smithery',
      name: 'Smithery',
      description: 'Extend your agent with 4,274 capabilities via Model Context Protocol servers.',
      url: 'https://smithery.ai/',
      servers_url: 'https://registry.smithery.ai/servers',
      tags: ['verified'],
      count: 4274,
    },
    {
      id: 'supermachine',
      name: 'SuperMachine',
      description: 'AI-powered tools and MCP servers for developers and businesses',
      url: 'https://supermachine.ai/',
      tags: ['verified'],
    },
    {
      id: 'zapier',
      name: 'Zapier MCP',
      description: 'Connect your AI to any app with Zapier MCP',
      url: 'https://zapier.com/mcp',
      tags: ['verified'],
    },
  ],
};



================================================
FILE: packages/mcp-registry-registry/src/registry/types.ts
================================================
import { z } from 'zod';

// Define the schema for server entries
export const ServerEntrySchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string(),
  createdAt: z.string(),
  updatedAt: z.string(),
});

export type ServerEntry = z.infer<typeof ServerEntrySchema>;

export interface RegistryEntry {
  id: string;
  name: string;
  description: string;
  url: string;
  servers_url?: string;
  tags?: string[];
  count?: number | string;
  // Custom post-processing function for this registry's server data
  postProcessServers?: (data: unknown) => ServerEntry[];
}

export interface RegistryFile {
  registries: RegistryEntry[];
}



================================================
FILE: packages/mcp-registry-registry/src/registry/__tests__/fetch-servers.test.ts
================================================
import { describe, expect, it, afterAll } from 'vitest';
import { getServersFromRegistry } from '../fetch-servers';
import type { ServerEntry } from '../types';

// This is an integration test that doesn't use mocking
// Note: This test requires internet access and will make actual API calls
describe('getServersFromRegistry integration test', () => {
  // Track registry test results for summary
  const registryResults: Record<string, { status: 'success' | 'error' | 'skipped'; message?: string }> = {};

  // Log a summary of all registry tests after completion
  afterAll(() => {
    console.log('\n=== Registry Test Summary ===');
    Object.entries(registryResults).forEach(([registry, result]) => {
      const statusSymbol = result.status === 'success' ? '✅' : result.status === 'error' ? '❌' : '⚠️';
      console.log(`${statusSymbol} ${registry}: ${result.status}${result.message ? ` - ${result.message}` : ''}`);
    });
    console.log('==========================\n');
  });

  it('should search servers by name or description', async () => {
    try {
      // First get all servers
      const allServers = await getServersFromRegistry('mcprun');

      if (allServers.count === 0) {
        console.warn('No servers found, skipping test');
        return;
      }

      // Pick a word from the first server's name or description to search for
      const firstServer = allServers;
      const searchWord = firstServer.name.split(' ')[0];

      if (!searchWord || searchWord.length < 3) {
        console.warn('Could not find suitable search term, skipping test');
        return;
      }

      // Search for that word
      const result = await getServersFromRegistry('mcprun', { search: searchWord });

      // We should find at least the server we got the word from
      expect(result.length).toBeGreaterThan(0);

      // At least one server should contain our search term in name or description
      const hasMatch = result.some(
        (server: ServerEntry) =>
          server.name.toLowerCase().includes(searchWord.toLowerCase()) ||
          server.description.toLowerCase().includes(searchWord.toLowerCase()),
      );

      expect(hasMatch).toBe(true);
    } catch (error) {
      console.warn('Error during search test, skipping:', error);
      return;
    }
  });

  it('should handle errors when registry is not found', async () => {
    try {
      // Try to get servers from a non-existent registry
      await getServersFromRegistry('non-existent-registry-id');
      // Should not reach here
      expect(true).toBe(false); // Force test to fail if we reach this point
    } catch (error) {
      // We expect an error to be thrown
      expect(error).toBeDefined();
      if (error instanceof Error) {
        expect(error.message).toContain('not found');
      }
    }
  });
});



================================================
FILE: packages/mcp-registry-registry/src/registry/__tests__/list-registries.test.ts
================================================
import { describe, expect, it } from 'vitest';
import { getRegistryListings } from '../list-registries';

// This test uses the actual registry.json file without any mocking
describe('getRegistryListings integration test', () => {
  it('should return all registries when no filters are provided', async () => {
    const result = await getRegistryListings();

    // The actual registry.json has 17 registries
    expect(result.count).toBeGreaterThan(0);
    expect(result.registries.length).toBeGreaterThan(0);
    // Check for some known registries
    expect(result.registries.map((r: any) => r.id)).toContain('mcprun');
    expect(result.registries.map((r: any) => r.id)).toContain('modelcontextprotocol-servers');
  });

  it('should filter registries by id', async () => {
    const result = await getRegistryListings({ id: 'mcprun' });

    expect(result.count).toBe(1);
    expect(result.registries.length).toBe(1);
    expect(result.registries[0].id).toBe('mcprun');
    expect(result.registries[0].name).toBe('MCP Run');
  });

  it('should filter registries by tag', async () => {
    const result = await getRegistryListings({ tag: 'verified' });

    expect(result.count).toBeGreaterThan(0);
    expect(result.registries.length).toBeGreaterThan(0);
    // Check for some known verified registries
    expect(result.registries.map((r: any) => r.id)).toContain('mcprun');
    expect(result.registries.map((r: any) => r.id)).toContain('apitracker');
    // Official is a different tag
    expect(result.registries.map((r: any) => r.id)).not.toContain('modelcontextprotocol-servers');
  });

  it('should filter registries by name search', async () => {
    const result = await getRegistryListings({ name: 'MCP' });

    expect(result.count).toBeGreaterThan(0);
    expect(result.registries.length).toBeGreaterThan(0);
    // Check for registries with MCP in the name
    expect(result.registries.map((r: any) => r.id)).toContain('mcprun');
    expect(result.registries.map((r: any) => r.id)).toContain('mcpso');
    // This registry doesn't have MCP in the name
    expect(result.registries.map((r: any) => r.id)).not.toContain('opentools');
  });

  it('should combine multiple filters', async () => {
    const result = await getRegistryListings({
      tag: 'verified',
      name: 'MCP',
    });

    expect(result.count).toBeGreaterThan(0);
    expect(result.registries.length).toBeGreaterThan(0);
    // Check for registries with MCP in the name and verified tag
    expect(result.registries.map((r: any) => r.id)).toContain('mcprun');
    expect(result.registries.map((r: any) => r.id)).toContain('mcpso');
    // This registry has the verified tag but not MCP in the name
    expect(result.registries.map((r: any) => r.id)).not.toContain('opentools');
  });

  it('should return detailed information when detailed option is true', async () => {
    const result = await getRegistryListings({ id: 'mcprun' }, { detailed: true });

    expect(result.count).toBe(1);
    expect(result.registries[0].id).toBe('mcprun');
    expect(result.registries[0].name).toBe('MCP Run');
    expect(result.registries[0].description).toBe('One platform for vertical AI across your entire organization.');
    expect(result.registries[0].url).toBe('https://www.mcp.run/');
    expect(result.registries[0].servers_url).toBe('https://www.mcp.run/api/servlets');
    expect(result.registries[0].tags).toEqual(['verified']);
  });

  it('should return only basic information when detailed option is false', async () => {
    const result = await getRegistryListings({ id: 'mcprun' }, { detailed: false });

    expect(result.count).toBe(1);
    expect(result.registries[0].id).toBe('mcprun');
    expect(result.registries[0].name).toBe('MCP Run');
    expect(result.registries[0].description).toBe('One platform for vertical AI across your entire organization.');
    expect(result.registries[0].url).toBeUndefined();
    expect(result.registries[0].servers_url).toBeUndefined();
    expect(result.registries[0].tags).toBeUndefined();
    expect(result.registries[0].count).toBeUndefined();
  });

  it('should return empty result when no registries match the criteria', async () => {
    const result = await getRegistryListings({ id: 'non-existent-id' });

    expect(result.count).toBe(0);
    expect(result.registries).toEqual([]);
  });

  it('should handle case insensitive name search', async () => {
    const result = await getRegistryListings({ name: 'mcp' });

    expect(result.count).toBeGreaterThan(0);
    // Should find registries with 'mcp' in the name regardless of case
    expect(result.registries.map((r: any) => r.id)).toContain('mcprun');
    expect(result.registries.map((r: any) => r.id)).toContain('mcpso');
  });
});



================================================
FILE: packages/mcp-registry-registry/src/registry/__tests__/processors/apify.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { getServersFromRegistry } from '../../fetch-servers';
import { processApifyServers } from '../../processors/apify';
import type { ServerEntry } from '../../types';

describe('Apify processor', () => {
  it('should process Apify server data correctly', async () => {
    try {
      // Use our getServersFromRegistry function to fetch data
      const result = await getServersFromRegistry('apify');

      // Verify the result
      expect(Array.isArray(result)).toBe(true);

      // Check that we got some servers
      expect(result.length).toBeGreaterThan(0);

      // Verify each server has the required fields
      result.forEach((server: ServerEntry) => {
        expect(server).toHaveProperty('id');
        expect(server).toHaveProperty('name');
        expect(server).toHaveProperty('description');
        expect(server).toHaveProperty('createdAt');
        expect(server).toHaveProperty('updatedAt');
      });
    } catch (error) {
      console.warn('Error during Apify test, may require authentication:', error);
      // Skip test if API requires authentication
    }
  });

  it('should handle empty or invalid data', () => {
    // Test with null
    expect(processApifyServers(null)).toEqual([]);

    // Test with undefined
    expect(processApifyServers(undefined)).toEqual([]);

    // Test with non-object
    expect(processApifyServers('not an object')).toEqual([]);

    // Test with empty object
    expect(processApifyServers({})).toEqual([]);

    // Test with empty array
    expect(processApifyServers([])).toEqual([]);

    // Test with empty data array
    expect(processApifyServers({ data: [] })).toEqual([]);
  });
});



================================================
FILE: packages/mcp-registry-registry/src/registry/__tests__/processors/apitracker.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { getServersFromRegistry } from '../../fetch-servers';
import { processApiTrackerServers } from '../../processors/apitracker';
import type { ServerEntry } from '../../types';

describe('APITracker processor', () => {
  it('should process APITracker server data correctly', async () => {
    // Use our getServersFromRegistry function to fetch data
    const result = await getServersFromRegistry('apitracker');

    // Verify the result
    expect(Array.isArray(result)).toBe(true);

    // Check that we got some servers
    expect(result.length).toBeGreaterThan(0);

    // Verify each server has the required fields
    result.forEach((server: ServerEntry) => {
      expect(server).toHaveProperty('id');
      expect(server).toHaveProperty('name');
      expect(server).toHaveProperty('description');
      expect(server).toHaveProperty('createdAt');
      expect(server).toHaveProperty('updatedAt');
    });
  });

  it('should handle empty or invalid data', () => {
    // Test with null
    expect(processApiTrackerServers(null)).toEqual([]);

    // Test with undefined
    expect(processApiTrackerServers(undefined)).toEqual([]);

    // Test with non-object
    expect(processApiTrackerServers('not an object')).toEqual([]);

    // Test with empty object
    expect(processApiTrackerServers({})).toEqual([]);

    // Test with empty array
    expect(processApiTrackerServers([])).toEqual([]);
  });
});



================================================
FILE: packages/mcp-registry-registry/src/registry/__tests__/processors/docker.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { getServersFromRegistry } from '../../fetch-servers';
import { processDockerServers } from '../../processors/docker';
import type { ServerEntry } from '../../types';

describe('Docker MCP processor', () => {
  it('should process Docker MCP server data correctly', async () => {
    try {
      // Use our getServersFromRegistry function to fetch data
      const result = await getServersFromRegistry('docker-mcp-catalog');

      // Verify the result
      expect(Array.isArray(result)).toBe(true);

      // Check that we got some servers
      expect(result.length).toBeGreaterThan(0);

      // Verify each server has the required fields
      result.forEach((server: ServerEntry) => {
        expect(server).toHaveProperty('id');
        expect(server).toHaveProperty('name');
        expect(server).toHaveProperty('description');
        expect(server).toHaveProperty('createdAt');
        expect(server).toHaveProperty('updatedAt');
      });
    } catch (error) {
      console.warn('Error during Docker MCP test, may require authentication:', error);
      // Skip test if API requires authentication
    }
  });

  it('should handle sample Docker MCP data correctly', () => {
    // Sample data from Docker Hub API
    const sampleData = {
      results: [
        {
          name: 'git',
          namespace: 'mcp',
          repository_type: null,
          status: 1,
          status_description: 'active',
          description: 'A Model Context Protocol server for Git repository interaction and automation',
          is_private: false,
          star_count: 3,
          pull_count: 4560,
          last_updated: '2025-04-16T15:05:48.044427Z',
          last_modified: '2025-04-26T15:41:19.129417Z',
          date_registered: '2024-12-19T20:39:42.265713Z',
          affiliation: '',
          media_types: ['application/vnd.oci.image.index.v1+json'],
          content_types: ['image'],
          categories: [
            {
              name: 'Machine Learning & AI',
              slug: 'machine-learning-and-ai',
            },
          ],
          storage_size: 954596202,
        },
      ],
    };

    // Process the sample data
    const servers = processDockerServers(sampleData);

    // Verify the results
    expect(servers).toHaveLength(1);

    // Check the server
    const server = servers[0];
    expect(server.id).toBe('git');
    expect(server.name).toBe('git');
    expect(server.description).toBe('A Model Context Protocol server for Git repository interaction and automation');
    expect(server.updatedAt).toBe('2025-04-16T15:05:48.044427Z');
  });

  it('should handle empty or invalid data', () => {
    // Test with null
    expect(processDockerServers(null)).toEqual([]);

    // Test with undefined
    expect(processDockerServers(undefined)).toEqual([]);

    // Test with non-object
    expect(processDockerServers('not an object')).toEqual([]);

    // Test with empty object
    expect(processDockerServers({})).toEqual([]);

    // Test with empty results array
    expect(processDockerServers({ results: [] })).toEqual([]);
  });
});



================================================
FILE: packages/mcp-registry-registry/src/registry/__tests__/processors/fleur.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { getServersFromRegistry } from '../../fetch-servers';
import { processFleurServers } from '../../processors/fleur';
import type { ServerEntry } from '../../types';

describe.skip('Fleur processor', () => {
  it('should process Fleur server data correctly', async () => {
    // Use our getServersFromRegistry function to fetch data
    const result = await getServersFromRegistry('fleur');

    // Verify the result
    expect(Array.isArray(result)).toBe(true);

    // Check that we got some servers
    expect(result.length).toBeGreaterThan(0);

    // Verify each server has the required fields
    result.forEach((server: ServerEntry) => {
      expect(server).toHaveProperty('id');
      expect(server).toHaveProperty('name');
      expect(server).toHaveProperty('description');
      expect(server).toHaveProperty('createdAt');
      expect(server).toHaveProperty('updatedAt');
    });
  });

  it('should handle empty or invalid data', () => {
    // Test with null
    expect(processFleurServers(null)).toEqual([]);

    // Test with undefined
    expect(processFleurServers(undefined)).toEqual([]);

    // Test with non-object
    expect(processFleurServers('not an object')).toEqual([]);

    // Test with empty object
    expect(processFleurServers({})).toEqual([]);

    // Test with empty array
    expect(processFleurServers([])).toEqual([]);
  });
});



================================================
FILE: packages/mcp-registry-registry/src/registry/__tests__/processors/mcprun.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { getServersFromRegistry } from '../../fetch-servers';
import { processMcpRunServers } from '../../processors/mcprun';
import type { ServerEntry } from '../../types';

describe('MCP Run processor', () => {
  it('should process MCP Run server data correctly', async () => {
    // Use our getServersFromRegistry function to fetch data
    const result = await getServersFromRegistry('mcprun');

    // Verify the result
    expect(Array.isArray(result)).toBe(true);

    // Check that we got some servers
    expect(result.length).toBeGreaterThan(0);

    // Verify each server has the required fields
    result.forEach((server: ServerEntry) => {
      expect(server).toHaveProperty('id');
      expect(server).toHaveProperty('name');
      expect(server).toHaveProperty('description');
      expect(server).toHaveProperty('createdAt');
      expect(server).toHaveProperty('updatedAt');
    });
  });

  it('should handle empty or invalid data', () => {
    // Test with null
    expect(processMcpRunServers(null)).toEqual([]);

    // Test with undefined
    expect(processMcpRunServers(undefined)).toEqual([]);

    // Test with non-object
    expect(processMcpRunServers('not an object')).toEqual([]);

    // Test with empty object
    expect(processMcpRunServers({})).toEqual([]);

    // Test with empty array
    expect(processMcpRunServers([])).toEqual([]);
  });
});



================================================
FILE: packages/mcp-registry-registry/src/registry/__tests__/processors/pulse.test.ts
================================================
import { describe, it, expect } from 'vitest';
import { getServersFromRegistry } from '../../fetch-servers';
import { processPulseMcpServers } from '../../processors/pulse';
import type { ServerEntry } from '../../types';

describe('Pulse MCP processor', () => {
  it('should process Pulse MCP server data correctly', async () => {
    try {
      // Use our getServersFromRegistry function to fetch data
      const result = await getServersFromRegistry('pulse-mcp');

      // Verify the result
      expect(Array.isArray(result)).toBe(true);

      // Check that we got some servers
      expect(result.length).toBeGreaterThan(0);

      // Verify each server has the required fields
      result.forEach((server: ServerEntry) => {
        expect(server).toHaveProperty('id');
        expect(server).toHaveProperty('name');
        expect(server).toHaveProperty('description');
        expect(server).toHaveProperty('createdAt');
        expect(server).toHaveProperty('updatedAt');
      });
    } catch (error) {
      console.warn('Error during Pulse MCP test, may require authentication:', error);
      // Skip test if API requires authentication
    }
  });

  it('should handle sample Pulse MCP data correctly', () => {
    // Sample data from Pulse MCP
    const sampleData = {
      servers: [
        {
          name: 'Laravel DebugBar',
          url: 'https://www.pulsemcp.com/servers/021-factory-laravel-debugbar',
          external_url: null,
          short_description:
            'Provides a bridge to Laravel DebugBar for accessing detailed request logs, queries, routes, views, and models with filtering capabilities and formatted output for improved readability.',
          source_code_url: 'https://github.com/021-factory/laravel-debugbar-mcp',
          github_stars: 1,
          package_registry: null,
          package_name: null,
          package_download_count: null,
          EXPERIMENTAL_ai_generated_description:
            'Laravel DebugBar MCP Server provides a bridge between AI assistants and the Laravel DebugBar debugging tool, enabling access to detailed request logs and diagnostic information from Laravel applications.',
        },
        {
          name: 'Taskwarrior',
          url: 'https://www.pulsemcp.com/servers/0xbeedao-taskwarrior26c9',
          external_url: null,
          short_description:
            'Integrates with Taskwarrior to enable task management through adding, updating, deleting, and listing tasks with project organization and priority level support.',
          source_code_url: 'https://github.com/0xbeedao/mcp-taskwarrior',
          github_stars: 0,
          package_registry: 'npm',
          package_name: '@0xbeedao/mcp-taskwarrior',
          package_download_count: 1056,
          EXPERIMENTAL_ai_generated_description:
            'mcp-taskwarrior is a server implementation by Bruce Kroeze that facilitates task management through Taskwarrior.',
        },
      ],
    };

    // Process the sample data
    const servers = processPulseMcpServers(sampleData);

    // Verify the results
    expect(servers).toHaveLength(2);

    // Check first server
    const server1 = servers[0];
    expect(server1.id).toBe('Laravel DebugBar');
    expect(server1.name).toBe('Laravel DebugBar');
    expect(server1.description).toBe(
      'Provides a bridge to Laravel DebugBar for accessing detailed request logs, queries, routes, views, and models with filtering capabilities and formatted output for improved readability.',
    );

    // Check second server
    const server2 = servers[1];
    expect(server2.id).toBe('Taskwarrior');
    expect(server2.name).toBe('Taskwarrior');
    expect(server2.description).toBe(
      'Integrates with Taskwarrior to enable task management through adding, updating, deleting, and listing tasks with project organization and priority level support.',
    );
  });

  it('should handle empty or invalid data', () => {
    // Test with null
    expect(processPulseMcpServers(null)).toEqual([]);

    // Test with undefined
    expect(processPulseMcpServers(undefined)).toEqual([]);

    // Test with non-object
    expect(processPulseMcpServers('not an object')).toEqual([]);

    // Test with empty object
    expect(processPulseMcpServers({})).toEqual([]);

    // Test with empty servers array
    expect(processPulseMcpServers({ servers: [] })).toEqual([]);
  });
});



================================================
FILE: packages/mcp-registry-registry/src/registry/processors/apify.ts
================================================
import type { ServerEntry } from '../types';

/**
 * Post-processor for Apify registry
 * Handles the specific format of Apify's store data
 */
export function processApifyServers(data: any): ServerEntry[] {
  // Get the data array from the response
  const apifyData = data?.data?.items || [];

  if (!Array.isArray(apifyData)) {
    return [];
  }

  // Map the data to server entries
  return apifyData
    .filter((item: any) => item && item.name)
    .map((item: any) => {
      // Extract stats for the updated date
      const stats = item.stats || {};

      const server = {
        id: item.name || 'unknown',
        name: item.title,
        description: item.description || 'No description available',
        createdAt: '', // Apify doesn't provide creation date
        updatedAt: stats.lastRunStartedAt || '',
      };

      return server;
    });
}



================================================
FILE: packages/mcp-registry-registry/src/registry/processors/apitracker.ts
================================================
import type { ServerEntry } from '../types';
import { createServerEntry } from './utils';

/**
 * Post-processor for APITracker registry
 * Handles the specific format of APITracker's server data
 */
export function processApiTrackerServers(data: unknown): ServerEntry[] {
  if (!data || typeof data !== 'object') {
    return [];
  }

  const servers: ServerEntry[] = [];

  // APITracker might return an object with a servers array
  if (typeof data === 'object' && data !== null) {
    const dataObj = data as Record<string, unknown>;

    let serversList: unknown[] = [];

    if (Array.isArray(dataObj.servers)) {
      serversList = dataObj.servers;
    } else if (Array.isArray(dataObj.items)) {
      serversList = dataObj.items;
    } else if (Array.isArray(data)) {
      serversList = data as unknown[];
    }

    for (const item of serversList) {
      if (typeof item === 'object' && item !== null) {
        servers.push(createServerEntry(item as Record<string, unknown>));
      }
    }
  }

  return servers;
}



================================================
FILE: packages/mcp-registry-registry/src/registry/processors/default.ts
================================================
import type { ServerEntry } from '../types';
import { createServerEntry } from './utils';

/**
 * Default processor for registry server data
 * Handles common formats that might be encountered
 */
export function processDefaultServers(data: unknown): ServerEntry[] {
  if (!data || typeof data !== 'object') {
    return [];
  }

  const servers: ServerEntry[] = [];

  // Handle different response formats
  let serversList: unknown[] = [];

  if (Array.isArray(data)) {
    // If the response is an array, assume it's an array of servers
    serversList = data;
  } else if (typeof data === 'object' && data !== null) {
    const dataObj = data as Record<string, unknown>;
    if (dataObj.servers && Array.isArray(dataObj.servers)) {
      // If the response has a 'servers' property, use that
      serversList = dataObj.servers;
    } else if (dataObj.items && Array.isArray(dataObj.items)) {
      // Some APIs might use 'items' instead of 'servers'
      serversList = dataObj.items;
    }
  }

  // Process each server in the list
  for (const item of serversList) {
    if (typeof item === 'object' && item !== null) {
      servers.push(createServerEntry(item as Record<string, unknown>));
    }
  }

  return servers;
}



================================================
FILE: packages/mcp-registry-registry/src/registry/processors/docker.ts
================================================
import type { ServerEntry } from '../types';
import { createServerEntry } from './utils';

/**
 * Post-processor for Docker MCP Hub registry
 * Transforms Docker Hub API response into standardized ServerEntry format
 */
export function processDockerServers(data: unknown): ServerEntry[] {
  if (!data || typeof data !== 'object') {
    return [];
  }

  const servers: ServerEntry[] = [];
  const results = (data as any)?.results || [];

  if (!Array.isArray(results)) {
    return [];
  }

  for (const item of results) {
    if (typeof item === 'object' && item !== null) {
      const server = createServerEntry(item as Record<string, unknown>);

      // Map Docker Hub specific fields
      if (item.name) {
        server.id = item.name;
        server.name = item.name;
      }

      // Use the first image's description if available
      if (Array.isArray(item.images) && item.images[0]?.description) {
        server.description = item.images[0].description;
      }

      // Use last_updated as updatedAt
      if (item.last_updated) {
        server.updatedAt = item.last_updated;
      }

      servers.push(server);
    }
  }

  return servers;
}



================================================
FILE: packages/mcp-registry-registry/src/registry/processors/fleur.ts
================================================
import type { ServerEntry } from '../types';
import { createServerEntry } from './utils';

/**
 * Post-processor for Fleur registry
 * Handles the specific format of Fleur's app data
 */
export function processFleurServers(data: unknown): ServerEntry[] {
  if (!data || typeof data !== 'object') {
    return [];
  }

  const servers: ServerEntry[] = [];

  // Fleur returns an array of app objects
  if (Array.isArray(data)) {
    for (const item of data) {
      if (typeof item === 'object' && item !== null) {
        const server = createServerEntry(item as Record<string, unknown>);

        // Handle Fleur specific fields
        if ((item as any).appId) {
          server.id = (item as any).appId;
        }

        servers.push(server);
      }
    }
  }

  return servers;
}



================================================
FILE: packages/mcp-registry-registry/src/registry/processors/mcprun.ts
================================================
import type { ServerEntry } from '../types';

// Post-processor for MCP Run registry
export function processMcpRunServers(data: any): ServerEntry[] {
  const serversData = data;

  if (!Array.isArray(serversData)) {
    return [];
  }

  return serversData
    .filter((item: any) => item && item.slug)
    .map((item: any) => {
      const server = {
        id: item.slug,
        name: item.slug,
        description: item?.meta?.description,
        createdAt: item?.created_at,
        updatedAt: item?.updated_at,
      };

      return server;
    });
}



================================================
FILE: packages/mcp-registry-registry/src/registry/processors/pulse.ts
================================================
import type { ServerEntry } from '../types';

/**
 * Post-processor for Pulse MCP registry
 * Handles the specific format of Pulse MCP's server data
 */
export function processPulseMcpServers(data: any): ServerEntry[] {
  // Get the servers array from the response
  const serversData = data?.servers || [];

  if (!Array.isArray(serversData)) {
    return [];
  }

  // Map the data to server entries
  return serversData
    .filter((item: any) => item && item.name)
    .map((item: any) => {
      const server = {
        id: item.name || 'unknown',
        name: item.name || 'Unknown Server',
        description:
          item.short_description.slice(0, 300) ||
          item.EXPERIMENTAL_ai_generated_description.slice(0, 300) ||
          'No description available',
        createdAt: '', // Pulse MCP doesn't provide creation date
        updatedAt: '', // Pulse MCP doesn't provide update date
      };

      return server;
    })
    .slice(0, 1000);
}



================================================
FILE: packages/mcp-registry-registry/src/registry/processors/utils.ts
================================================
import type { ServerEntry } from '../types';

// Helper function to create a basic server entry from partial data
export function createServerEntry(data: Record<string, unknown>): ServerEntry {
  // Safely access nested properties
  const metaDescription =
    typeof data.meta === 'object' && data.meta !== null
      ? ((data.meta as Record<string, unknown>).description as string)
      : undefined;

  return {
    id: (data.id as string) || (data.name as string) || (data.slug as string) || 'unknown',
    name: (data.name as string) || (data.id as string) || (data.slug as string) || 'Unknown Server',
    description: (data.description as string) || metaDescription || 'No description available',
    createdAt: (data.createdAt as string) || (data.created_at as string) || '',
    updatedAt: (data.updatedAt as string) || (data.updated_at as string) || '',
  };
}



================================================
FILE: packages/mcp-registry-registry/src/tools/list.ts
================================================
import { z } from 'zod';
import { getRegistryListings } from '../registry/list-registries';

// Define the input schema for the registry listing tool
export const listInputSchema = z.object({
  id: z.string().optional(),
  tag: z.string().optional(),
  name: z.string().optional(),
  detailed: z.boolean().optional().default(false),
});

export type ListToolInput = z.infer<typeof listInputSchema>;

// Define the registry listing tool
export const listTool = {
  name: 'registryList',
  description: 'List available MCP registries. Can filter by ID, tag, or name and provide detailed or summary views.',
  async execute(input: ListToolInput) {
    try {
      const result = await getRegistryListings(
        {
          id: input.id,
          tag: input.tag,
          name: input.name,
        },
        {
          detailed: input.detailed,
        },
      );

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: `Error listing registries: ${error instanceof Error ? error.message : String(error)}`,
          },
        ],
        isError: true,
      };
    }
  },
};



================================================
FILE: packages/mcp-registry-registry/src/tools/servers.ts
================================================
import { z } from 'zod';
import { getServersFromRegistry } from '../registry/fetch-servers';

// Define the input schema for the servers tool
export const serversInputSchema = z.object({
  registryId: z.string(),
  tag: z.string().optional(),
  search: z.string().optional(),
});

export type ServersToolInput = z.infer<typeof serversInputSchema>;

// Define the servers tool
export const serversTool = {
  name: 'registryServers',
  description: 'Get servers from a specific MCP registry. Can filter by tag or search term.',
  async execute(input: ServersToolInput) {
    try {
      const result = await getServersFromRegistry(input.registryId, {
        tag: input.tag,
        search: input.search,
      });

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: 'text',
            text: `Error fetching servers: ${error instanceof Error ? error.message : String(error)}`,
          },
        ],
        isError: true,
      };
    }
  },
};


