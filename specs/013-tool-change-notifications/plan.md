# Implementation Plan: Tool Change Notifications

**Branch**: `013-tool-change-notifications` | **Date**: 2025-12-20 | **Spec**: [spec.md](./spec.md)
**Issue**: https://github.com/smart-mcp-proxy/mcpproxy-go/issues/209
**Input**: Feature specification from `/specs/013-tool-change-notifications/spec.md`

## Summary

Implement reactive tool discovery by subscribing to MCP `notifications/tools/list_changed` notifications from upstream servers. When a server updates its tools, MCPProxy will automatically re-index within seconds instead of waiting up to 5 minutes for the background polling cycle.

## Technical Context

**Language/Version**: Go 1.24 (toolchain go1.24.10)
**Primary Dependencies**: github.com/mark3labs/mcp-go v0.43.1
**Storage**: BBolt database (`~/.mcpproxy/config.db`), Bleve index (`~/.mcpproxy/index.bleve/`)
**Testing**: go test, E2E scripts (`./scripts/test-api-e2e.sh`)
**Target Platform**: Linux, macOS, Windows (cross-platform)
**Project Type**: Single project with 3-layer upstream client architecture
**Performance Goals**: Tool re-indexing within 5 seconds of notification (down from 5 minutes)
**Constraints**: Must maintain backward compatibility with servers not supporting notifications
**Scale/Scope**: Supports up to 1,000 tools across multiple servers

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Performance at Scale | PASS | Notification-triggered discovery is async, non-blocking |
| II. Actor-Based Concurrency | PASS | Uses existing callback patterns, no new locks needed |
| III. Configuration-Driven | PASS | No new config options, auto-detects capability |
| IV. Security by Default | PASS | No security changes, uses existing discovery |
| V. Test-Driven Development | PASS | Unit + Integration + E2E tests planned |
| VI. Documentation Hygiene | PASS | Docs updates included in spec |

**Architecture Constraints**:
| Constraint | Status | Notes |
|------------|--------|-------|
| Core + Tray Split | PASS | Changes only in core, no tray changes |
| Event-Driven Updates | PASS | Uses MCP notification events |
| DDD Layering | PASS | Follows core → managed → runtime flow |
| 3-Layer Upstream | PASS | Callback registered at each layer appropriately |

## Project Structure

### Documentation (this feature)

```text
specs/013-tool-change-notifications/
├── plan.md              # This file
├── research.md          # Phase 0 research findings
├── data-model.md        # Data model extensions
├── quickstart.md        # Developer quickstart guide
├── contracts/           # API contracts (minimal for this feature)
│   └── README.md
└── tasks.md             # Phase 2 output (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
internal/upstream/
├── core/
│   ├── client.go        # Add onToolsChanged callback field + setter
│   └── connection.go    # Register OnNotification handler after Start()
├── managed/
│   └── client.go        # Wire callback, add toolDiscoveryCallback
└── manager.go           # Set discovery callback on managed clients

internal/runtime/
└── lifecycle.go         # Existing DiscoverAndIndexToolsForServer (no changes)

tests/
└── notification_test.go # New unit tests for notification handling

docs/
├── features/
│   └── search-discovery.md  # Add notification section
└── api/
    └── mcp-protocol.md      # Document notification behavior
```

**Structure Decision**: Single project structure. Changes span the 3-layer upstream architecture following established patterns.

## Complexity Tracking

> No constitution violations requiring justification.

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| N/A | N/A | N/A |

## Implementation Phases

### Phase 1: Core Notification Infrastructure

**Goal**: Add callback mechanism in core client and register notification handler.

**Files**:
- `internal/upstream/core/client.go`: Add `onToolsChanged` field and setter
- `internal/upstream/core/connection.go`: Register `OnNotification` handler

**Key Code**:
```go
// In client.go
type Client struct {
    onToolsChanged func(serverName string)
}

func (c *Client) SetOnToolsChangedCallback(callback func(serverName string)) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.onToolsChanged = callback
}

// In connection.go (after client.Start())
c.client.OnNotification(func(notification mcp.JSONRPCNotification) {
    if notification.Notification.Method == mcp.MethodNotificationToolsListChanged {
        c.logger.Info("Received tools/list_changed notification",
            zap.String("server", c.config.Name))
        if c.onToolsChanged != nil {
            c.onToolsChanged(c.config.Name)
        }
    }
})
```

**Tests**: Unit tests for callback registration and invocation.

---

### Phase 2: Managed Client Integration

**Goal**: Wire core callback to managed layer, forward to runtime.

**Files**:
- `internal/upstream/managed/client.go`: Add `toolDiscoveryCallback`, wire core callback

**Key Code**:
```go
// In managed/client.go
type Client struct {
    toolDiscoveryCallback func(ctx context.Context, serverName string) error
}

func (c *Client) SetToolDiscoveryCallback(cb func(ctx context.Context, serverName string) error) {
    c.toolDiscoveryCallback = cb
}

// In NewClient or appropriate init:
c.core.SetOnToolsChangedCallback(func(serverName string) {
    if c.toolDiscoveryCallback != nil {
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        if err := c.toolDiscoveryCallback(ctx, serverName); err != nil {
            c.logger.Error("Notification-triggered discovery failed",
                zap.String("server", serverName), zap.Error(err))
        }
    }
})
```

**Tests**: Unit tests for callback forwarding.

---

### Phase 3: Manager and Runtime Integration

**Goal**: Connect managed client callback to runtime's discovery function.

**Files**:
- `internal/upstream/manager.go`: Set callback during client creation

**Key Code**:
```go
// In manager.go AddServer():
client.SetToolDiscoveryCallback(func(ctx context.Context, serverName string) error {
    return m.runtime.DiscoverAndIndexToolsForServer(ctx, serverName)
})
```

**Tests**: Integration test verifying full notification → discovery flow.

---

### Phase 4: Capability Awareness (Optional Enhancement)

**Goal**: Log capability status, warn on unexpected notifications.

**Files**:
- `internal/upstream/core/connection.go`: Add capability check after init

**Key Code**:
```go
// After initialize() succeeds:
if c.serverInfo.Capabilities.Tools != nil && c.serverInfo.Capabilities.Tools.ListChanged {
    c.logger.Debug("Server supports tool change notifications",
        zap.String("server", c.config.Name))
} else {
    c.logger.Debug("Server does not support tool change notifications",
        zap.String("server", c.config.Name))
}
```

---

### Phase 5: Documentation Updates

**Goal**: Update online docs to reflect new behavior.

**Files**:
- `docs/features/search-discovery.md`: Add "Automatic Updates" section
- `docs/api/mcp-protocol.md`: Document notification handling
- `CLAUDE.md`: Add to implementation details

---

### Phase 6: Testing

**Goal**: Comprehensive test coverage.

**Files**:
- `internal/upstream/core/notification_test.go`: Unit tests
- `internal/upstream/managed/notification_test.go`: Unit tests
- `internal/server/e2e_notification_test.go`: E2E test

**Test Scenarios**:
1. Handler registration after Start()
2. Callback invocation on notification
3. Filtering (only tools/list_changed)
4. Deduplication via discoveryInProgress
5. Full flow: notification → index update

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| mcp-go API changes | Low | High | Pin version, monitor releases |
| Notification flood | Low | Medium | Existing deduplication handles this |
| Connection race conditions | Medium | Low | Use existing mutex patterns |
| Backward compatibility | Low | Low | Polling continues for non-supporting servers |

## Dependencies

### External
- mcp-go v0.43.1 (already included)

### Internal
- `internal/runtime/lifecycle.go`: `DiscoverAndIndexToolsForServer` (no changes needed)
- `internal/upstream/core/`: Existing connection infrastructure
- `internal/upstream/managed/`: Existing managed client

## Success Metrics

1. **Latency**: Tool updates reflected within 5 seconds (verified via logs)
2. **Compatibility**: Existing 5-minute polling still works (verified via test)
3. **Stability**: No crashes or deadlocks during notification processing
4. **Coverage**: >80% test coverage on new code

## Timeline Estimation

| Phase | Complexity |
|-------|------------|
| Phase 1: Core Infrastructure | Low |
| Phase 2: Managed Integration | Low |
| Phase 3: Manager/Runtime | Low |
| Phase 4: Capability Awareness | Low |
| Phase 5: Documentation | Low |
| Phase 6: Testing | Medium |

**Total Complexity**: Low-Medium (straightforward callback wiring with existing patterns)
